插入排序：
template<typename t>
void insertSort(T data[],int n){
  for(int i=1;i<n;i++){
    T tmp=data[i];
    for(int j=i;j>0&&tmp<data[j-1];j--){
      data[j]=data[j-1];
    }
    data[j]=tmp;
  }
}
时间复杂度O(n2)。



选择排序：
template<typename T>
void selectionSort(T data[],int n){
	for(int i=0,j,least;i<n-1;i++){
		for(j=i+1,least=i;j<n;j++){
			if(data[j]<data[least]){
				least=j;
			}
		}
		swap(data[least],data[i]);
	}
}
时间复杂度O(n2)



冒泡排序：
template<typename T>
void bubbleSort(T data[],int n){
	for(int i=0;i<n-1;i++){
		for(int j=n-1;j>i;j--){
			if(data[j]<data[j-1]){
				swap(data[j],data[j-1]);
			}
		}
	}
}


void bubbleSort(T data[],int n){
	bool sorted=false;
	while(!sorted){
		sorted=true;
		for(int i=1;i<n;i++){
			if(data[i-1]>data[i]){
				swap(data[j-1],data[j]);
				sorted=false;
			}
		}
		n--;
	}
}
时间复杂度O(n2)


Shell排序：
Shell排序的执行时间依赖于增量序列。
好的增量序列的共同特征：
① 最后一个增量必须为1；
② 应该尽量避免序列中的值(尤其是相邻的值）互为倍数的情况。
有人通过大量的实验，给出了目前较好的结果：当n较大时，比较和移动的次数约在n到1.6n之间
void shellsort(int a[], int n)
{
	int i, j, gap;
	for (gap = n / 2; gap > 0; gap /= 2)
		for (i = gap; i < n; i++)
			for (j = i - gap; j >= 0 && a[j] > a[j + gap]; j -= gap)
				Swap(a[j], a[j + gap]);
}
